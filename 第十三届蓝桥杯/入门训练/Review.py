''''''
'''
问题描述
　　给定一个1～N的排列a[i]，每次将相邻两个数相加，得到新序列，再对新序列重复这样的操作，显然每次得到的序列都比上一次的序列长度少1，最终只剩一个数字。
　　例如:
　　3 1 2 4
　　4 3 6
　　7 9
　　16
　　现在如果知道N和最后得到的数字sum，请求出最初序列a[i]，为1～N的一个排列。若有多种答案，则输出字典序最小的那一个。数据保证有解。
输入格式
　　第1行为两个正整数n，sum
输出格式
　　一个1～N的一个排列
样例输入
4 16
样例输出
3 1 2 4
数据规模和约定
　　0<n<=10
'''

'''
A城市有一个巨大的圆形广场，为了绿化环境和净化空气，市政府决定沿圆形广场外圈种一圈树。园林部门得到指令后，
初步规划出n个种树的位置，顺时针编号1到n。并且每个位置都有一个美观度Ai，如果在这里种树就可以得到这Ai的美观度。
但由于A城市土壤肥力欠佳，两棵树决不能种在相邻的位置（i号位置和i+1号位置叫相邻位置。值得注意的是1号和n号也算相邻位置！）。
最终市政府给园林部门提供了m棵树苗并要求全部种上，请你帮忙设计种树方案使得美观度总和最大。如果无法将m棵树苗全部种上，给出无解信息。

输入
输入的第一行包含两个正整数n、m。
第二行n个整数Ai。

数据规模和约定

对于全部数据，满足1< =m< =n< =30；
其中90%的数据满足m< =n< =20
-1000< =Ai< =1000
输出
输出一个整数，表示最佳植树方案可以得到的美观度。如果无解输出“Error!”，不包含引号。
样例输入
7 3
1 2 3 4 5 6 7
样例输出
15
'''
n, m = map(int, input().split())
A = list(map(int, input().split()))
position = [i + 1 for i in range(len(A))]

def Bubble_Sort(li_1, li_2):
    for i in range(len(li_1) - 1):
        Whether_Exchange = False
        for j in range(len(li_1) - i - 1):
            if li_1[j] > li_1[j + 1]:
                li_1[j], li_1[j + 1] = li_1[j + 1], li_1[j]
                li_2[j], li_2[j + 1] = li_2[j + 1], li_2[j]
                Whether_Exchange = True
        if not Whether_Exchange:
            return

Bubble_Sort(A, position)
total = 0
idx = len(A) - 1
while m > 0:
    total += A[idx]
    m -= 1
    idx