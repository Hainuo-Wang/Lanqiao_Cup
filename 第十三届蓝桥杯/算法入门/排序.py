import random
from Calculate_Time import *

'''
排序：将一组”无序“的记录序列调整为“有序”的记录序列

列表排序：将无序列表变为有序列表
输入：列表
输出：有序列表

升序与降序

内置排序函数：sort()
'''
# ----------------------------------------------------------------------------------------------------------------------
'''
冒泡排序：
  列表每两个相邻的数，如果前面比后面的大，则交换这两个数。
  一趟排序完成后，无序区减少一个数，有序区增加一个数。
  前面无序区中最大的数像冒泡一样一点一点移动到后面有序区中相应的位置。
  
代码关键点：
  长度为n的列表，一共n-1趟
  第i趟时，无序区范围是[0: n-i-1]，其中i范围是[0, n-1]
  
时间复杂度：O(n^2)
'''
@Cal_Ti
def Bubble_Sort(li):
    for i in range(len(li) - 1):
        Whether_Exchange = False  # 每趟开始前，Whether_Exchange设置为False
        for j in range(len(li) - i - 1):
            if li[j] > li[j + 1]:  # 改成<，就变成降序
                li[j], li[j + 1] = li[j + 1], li[j]
                Whether_Exchange = True  # 若一趟下来有至少一次交换，则Whether_Exchange为True
        if not Whether_Exchange:  # 如果一趟下来没有进行一次交换，说明列表已经排好序，直接退出
            return

li = [random.randint(0, 1000) for i in range(1000)]
print('Initial List: ', li)
Bubble_Sort(li)
print('Bubble Sort: ', li)
# ----------------------------------------------------------------------------------------------------------------------
'''
选择排序：
  刚开始的整个列表看成一个无序区，从无序区中选出最小的数，和无序区中第1个数进行交换，
  此时无序区长度减1，有序区长度加1变为1，
  每一次都选出无序区中最小的数放到有序区最后，共需要n-1次，
  第n-1次中，无序区剩下最后两个数，选出较小的数，即整个列表第二小的数，放在有序区最后，此时排序结束。
  
代码关键点：
  长度为n的列表，共选择n-1次，
  第i次选择，无序区的范围是[i, n)
  无序区中最小的数位置

时间复杂度：O(n^2)
'''
@Cal_Ti
def Select_Sort(li):
    for i in range(len(li) - 1):
        min_idx = i  # 选择前，假定无序区当前最小的数就是无序区的第一个数
        for j in range(i + 1, len(li)):  # 从无序区第二个数开始，选择比当前最小值更小的数的索引
            if li[j] < li[min_idx]:
                min_idx = j  # 新的最小的数的下标
        li[i], li[min_idx] = li[min_idx], li[i]  # 选择一趟后，找到了无序区中最小数的索引min_idx]

li = [random.randint(0, 1000) for i in range(1000)]
print('Initial List: ', li)
Select_Sort(li)
print('Select Sort: ', li)
# ----------------------------------------------------------------------------------------------------------------------
'''
插入排序：
  打牌时，初始时手里（有序区）只有一张牌，每次（从无序区）摸一张牌，插入到手里已有牌的正确位置，一共要摸n-1次牌。
  插入时，手中（有序区）的牌是从前往后由小到大排列的，从最后一个开始和新摸的牌比较，若比新摸的牌大，就往后移一个位置，
  空出来一个位置，接着向前依次比较，直到比新摸的牌小，就不向后移动了，将新摸的牌插到此时的空位置。

时间复杂度：O(n^2)
'''
@Cal_Ti
def Insert_Sort(li):
    for i in range(1, len(li)):  # i是新摸到的牌的下标
        tmp = li[i]
        j = i - 1  # j此时是手里最后一张牌的下标
        while li[j] > tmp and j >= 0:
            li[j + 1] = li[j]  # 若大于新摸到的牌，就往后移一个位置
            j -= 1  # 要比较的位置往前移动一个，直到下标为0的牌，若也大于新摸到的牌，此时li[1] = li[0]，空出来的就是第一个位置li[0]
        li[j + 1] = tmp  # 空出来的位置插入tmp

li = [random.randint(0, 1000) for i in range(1000)]
print('Initial List: ', li)
Insert_Sort(li)
print('Insert Sort: ', li)
'''
def Insert_Sort(li):
    for i in range(len(li) - 1):  # 需要摸n-1张新牌
        j = i + 1  # 第i次摸牌时，新牌在待排序列表中的下标为i+1
        temp = li[j]  # 记录下新牌的牌数
        while temp < li[j - 1] and j > 0:  # 比较新牌和手中从小到大排序过的牌，从手中最后一张开始比较
            li[j] = li[j - 1]  # 从手中最后一张牌开始，若牌数大于新摸的牌数，就将手中的牌向后移动一个位置，留出来一个空位
            j -= 1
        li[j] = temp  # 知道跳出循环，即正在对比的手中的牌小于或等于新摸的牌或者已经比完了手中所有的牌，将新摸的牌查到空位置即满足顺序
'''
# ----------------------------------------------------------------------------------------------------------------------
'''
快速排序：
'''