# 问题描述
# 　　回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。
# 　　交换的定义是：交换两个相邻的字符
# 　　例如mamad
# 　　第一次交换 ad : mamda
# 　　第二次交换 md : madma
# 　　第三次交换 ma : madam (回文！完美！)
# 输入格式
# 　　第一行是一个整数N，表示接下来的字符串的长度(N <= 8000)
# 　　第二行是一个字符串，长度为N.只包含小写字母
# 输出格式
# 　　如果可能，输出最少的交换次数。
# 　　否则输出Impossible
# 样例输入
# 5
# mamad
# 样例输出
# 3
# 解题思路
# 两种情况：
# 1.impossible的情况：如果有一个字符出现的次数是奇数次数，而且n是偶数，那么不可能构成回文。
# 如果n是奇数，但是已经有一个字符出现的次数是奇数次数了，那么如果又有一个字符是奇数次数，就不可能构成回文。
# 2.如果n是奇数，计算中间那个字符交换的次数的时候，不需要模拟把这个数移动到中间去，
# 因为移动到中间的话假设有一对数都在左边或者都在右边。
# 那么交换成回文的时候就要经过中间，就会每次把cnt多加了1，而这个1是没有必要的，
# 因为可以所有的回文移动完了之后再把这个独立的奇数移动过去，才能保证交换次数最少。

n = int(input())
pal = list(input())
count = flag = 0  # count计数，flag判断是否已经有一个单独的奇个数的字符了
m = n - 1
for i in range(m):  # 从头遍历到倒数第二个字符
    for k in range(m, i - 1, -1):  # 从后往前一直到i寻找和pal[i]相同的pal[k]
        if k == i:  # 如果找不到相同的
            if n % 2 == 0 or flag == 1:  # impossible的两种情况
                print('Impossible')
                exit()
            flag = 1
            count += int(n / 2) - i
        elif pal[k] == pal[i]:
            for j in range(k, m):
                pal[j], pal[j + 1] = pal[j + 1], pal[j]
                count += 1  # 计数器加1
            m -= 1  # 最后拍好序的不在进行比较
            break
print(count)


