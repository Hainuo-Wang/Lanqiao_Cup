# 问题描述
# 　　小袁非常喜欢滑雪， 因为滑雪很刺激。为了获得速度，滑的区域必须向下倾斜，
# 而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。 小袁想知道在某个
# 区域中最长的一个滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。如下：
# 1   2   3   4   5
# 16  17  18  19  6
# 15  24  25  20  7
# 14  23  22  21  8
# 13  12  11  10  9
# 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。
# 在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-…-3-2-1更长。事实上，这是最长的一条。
# 　　你的任务就是找到最长的一条滑坡，并且将滑坡的长度输出。 滑坡的长度定义为经过点的个数，例如滑坡24-17-16-1的长度是4。
# 输入格式
# 　　输入的第一行表示区域的行数R和列数C(1<=R, C<=10)。下面是R行，每行有C个整数，依次是每个点的高度h（0<= h <=10000）。
# 输出格式
# 　　只有一行，为一个整数，即最长区域的长度。
# 样例输入
# 5 5
# 1 2 3 4 5
# 16 17 18 19 6
# 15 24 25 20 7
# 14 23 22 21 8
# 13 12 11 10 9
# 样例输出
# 25
# 解题思路：
# 1.偶然发现了一种二位数组输入的更简便方式：
# arr = [list(map(int, input().split())) for _ in range(row)]
# 以后按二维数组的输入统统按此方法处理，前边已经写好的代码不再进行修改。
# 2.对于区域内每个点进行dfs，对每个点来说进行四个方向的dfs取最大值，然后取所有点为起点的最大长度的最大值，即为答案。
# 3.详细解释在代码块中相应位置给出。
def dfs(x, y):
    """
    深度递归搜索
    :param x: 横坐标
    :param y: 纵坐标
    :return: 最大距离
    """
    max_height = 1  # 初始距离为1
    if dp[x][y] > 0:  # 如果已经有了当前位置出发的最大距离，则直接返回
        return dp[x][y]
    for k in range(4):  # 判断该位置的上下左右四个位置
        tx = x + next_[k][0]
        ty = y + next_[k][1]
        if tx < 0 or tx >= row or ty < 0 or ty >= col:  # 越界情况
            continue
        if arr[tx][ty] >= arr[x][y]:  # 不符合高到低的情况
            continue
        max_height = max(max_height, dfs(tx, ty) + 1)  # 符合，递归搜索下一个位置且距离加1
        dp[x][y] = max_height  # 最终距离放在此矩阵中保存
        return dp[x][y]  # 返回该位置下的最大距离


row, col = map(int, input().split())
dp = [[0 for _ in range(col)] for _ in range(row)]  # 记录从每个位置(x, y)开始，它的最大长度
arr = [list(map(int, input().split())) for _ in range(row)]
next_ = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 用来表示(x, y)的上下左右四个位置
ans = 0
for i in range(row):
    for j in range(col):
        ans = max(ans, dfs(i, j))
print(ans)
