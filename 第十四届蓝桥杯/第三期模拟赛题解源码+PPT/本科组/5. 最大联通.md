### 题目大意

小蓝有一个 $30$ 行 $60$ 列的数字矩阵，矩阵中的每个数都是 $0$ 或 $1$ 。
```
110010000011111110101001001001101010111011011011101001111110
010000000001010001101100000010010110001111100010101100011110 
001011101000100011111111111010000010010101010111001000010100 
101100001101011101101011011001000110111111010000000110110000 
010101100100010000111000100111100110001110111101010011001011 
010011011010011110111101111001001001010111110001101000100011 
101001011000110100001101011000000110110110100100110111101011 
101111000000101000111001100010110000100110001001000101011001 
001110111010001011110000001111100001010101001110011010101110 
001010101000110001011111001010111111100110000011011111101010 
011111100011001110100101001011110011000101011000100111001011 
011010001101011110011011111010111110010100101000110111010110 
001110000111100100101110001011101010001100010111110111011011 
111100001000001100010110101100111001001111100100110000001101 
001110010000000111011110000011000010101000111000000110101101 
100100011101011111001101001010011111110010111101000010000111 
110010100110101100001101111101010011000110101100000110001010 
110101101100001110000100010001001010100010110100100001000011 
100100000100001101010101001101000101101000000101111110001010 
101101011010101000111110110000110100000010011111111100110010 
101111000100000100011000010001011111001010010001010110001010 
001010001110101010000100010011101001010101101101010111100101 
001111110000101100010111111100000100101010000001011101100001 
101011110010000010010110000100001010011111100011011000110010 
011110010100011101100101111101000001011100001011010001110011 
000101000101000010010010110111000010101111001101100110011100 
100011100110011111000110011001111100001110110111001001000111 
111011000110001000110111011001011110010010010110101000011111 
011110011110110110011011001011010000100100101010110000010011 
010011110011100101010101111010001001001111101111101110011101
```

### 解题思路
枚举地图中的所有的点：

+ 若该点为 $1$ ，统计该块中的所有的 $1$ 的个数，更新最大值答案，之后清除该块 $1$ 将 $1$ 置为 $0$ 或使用标记数组对该块所有的 $1$ 进行标记，防止多次访问。
+ 若该点为 $0$ ，则跳过该点。

### AC_Code

+ C++

```CPP
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;

const int N = 1e2 + 10;

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

int n = 30, m = 60;
char g[N][N];

int dfs(int x, int y)
{
    if (g[x][y] == '0')
        return 0;
    g[x][y] = '0';
    int res = 1;
    for (int i = 0; i < 4; ++ i )
    {
        int tx = x + dx[i], ty = y + dy[i];
        if (tx < 0 || ty < 0 || tx >= n || ty >= m)
            continue;
        res += dfs(tx, ty);
    }
    return res;
}

int main()
{
    for (int i = 0; i < n; ++ i )
        cin >> g[i];
    int res = 0;
    for (int i = 0; i < n; ++ i )
        for (int j = 0; j < m; ++ j )
            if (g[i][j] == '1')
                res = max(res, dfs(i, j));
    cout << res << endl;
    return 0;
}
/*

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

int main()
{
    puts("148");
    return 0;
}

*/
```

+ Java

```cpp
import java.util.Scanner;

public class main {
	
	static int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
	static int n = 30, m = 60;
	static String[] g = new String[110];
	static Boolean[][] st = new Boolean[110][110];
	
	static int dfs(int x, int y) {
		if (g[x].charAt(y) == '0' || st[x][y] == true)
	        return 0;
	    st[x][y] = true;
	    int res = 1;
	    for (int i = 0; i < 4; ++ i )
	    {
	        int tx = x + dx[i], ty = y + dy[i];
	        if (tx < 0 || ty < 0 || tx >= n || ty >= m)
	            continue;
	        res += dfs(tx, ty);
	    }
	    return res;
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		for (int i = 0; i < n; ++ i )
			g[i] = sc.next();
		for (int i = 0; i < n; ++ i )
			for (int j = 0; j < m; ++ j )
				st[i][j]= false; 
		int res = 0;
		for (int i = 0; i < n; ++ i )
			for (int j = 0; j < m; ++ j )
				if (g[i].charAt(j) == '1')
					res = Math.max(res, dfs(i, j));
		System.out.println(res);
	}
	
}
```

- Python

```python
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]
n = 30
m = 60

def dfs(x, y):
    if g[x][y] == '0':
        return 0
    g[x][y] = '0'
    res = 1
    for i in range(4):
        tx = x + dx[i]
        ty = y + dy[i]
        if tx < 0 or ty < 0 or tx >= n or ty >= m:
            continue
        res += dfs(tx, ty)
    return res

g = list()
for i in range(n):
     li =  list(map(str, input()))
     g.append(li)

res = 0
for i in range(n):
    for j in range(m):
        if g[i][j] == '1':
            res = max(res, dfs(i, j))
print(res)
```

